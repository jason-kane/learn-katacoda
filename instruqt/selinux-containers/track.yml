challenges:
- assignment: "# Software installation and configuration\nSELinux is a technology\
    \ to isolate processes/containers running on the system to mitigate attacks which\
    \ take \nadvantage of privilege escalation. Udica is a new tool which complements\
    \ the containers tools (Podman, Skopeo, Buildah, etc.) \nfamily supported by Red\
    \ Hat to help improve the security of customers container environments.\n\n>_NOTE:_\
    \ This lab assumes that you have a sound understanding of SELinux basics and container\
    \ fundamentals. \n\nPrior to getting started, we need certain packages such as\
    \ Udica (which is a tool for generating \nSELinux policies for containers), and\
    \ setools-console (which is a set of tools that can facilitate \nSELinux policy\
    \ analysis). In this demo, the container runtime related packages are already\
    \ installed.\n\nThere are 2 terminal tabs that will be used in this lab - a terminal\
    \ on the container host (indicated by *Terminal*), and a second terminal \nwhere\
    \ we will run the container (indicated by *Terminal 2*).\n\nInstall the udica\
    \ and setools-console packages on the container host\n\n`yum install -y udica\
    \ setools-console`{{execute T1}}\n\nGet the latest RHEL8 UBI image \n`podman pull\
    \ registry.access.redhat.com/ubi8/ubi:latest`{{execute T1}}\n\nUse `podman` to\
    \ list the available container images \n\n`podman images`{{execute T1}}\n\nIn\
    \ 'Terminal 2' tab of the lab interface, create a container runtime using podman\
    \ which -\npasses in-container accesses to /home through to the host's /home read-only,\
    \ passes in-container \naccesses to /var/spool through to the host's /var/spool\
    \ read-write, and binds the \nhost's port 80 to pass traffic to the container's\
    \ port 80.\n\n`CONTAINER=$(podman run -v /home:/home:ro -v /var/spool:/var/spool:rw\
    \ -d -p 80:80 -it registry.access.redhat.com/ubi8/ubi)`{{execute T2}}\n\n>_NOTE:_\
    \ The home directory is mounted with read-only access, and the /var/spool/ directory\
    \ is mounted with read-write access.\n\nIn the 'Terminal' tab of the lab interface,\
    \ check the status of the application container using podman and get the running\
    \ container id \n\n`podman ps; CONTAINERID=$(podman ps | grep registry.access.redhat.com\
    \ | cut -b 1-12)`{{execute T1}}\n\n<pre class=\"file\">\nCONTAINER ID  IMAGE \
    \                        COMMAND               CREATED        STATUS         \
    \  PORTS               NAMES\ne47a11d3e2c5  registry.access.redhat.com/ubi8/ubi:latest\
    \  /bin/bash  3 seconds ago  Up 2 seconds ago0.0.0.0:80->80/tcp  naughty_golick\n\
    </pre>\n\nWhen using SELinux, container processes get assigned a container type\
    \ called 'container_t'. Verify the SELinux type assigned to the running container\n\
    \n`ps -eZ | grep container_t`{{execute T1}}\n\n<pre class=\"file\">\nsystem_u:system_r:container_t:s0:c182,c1016\
    \ 25755 pts/0 00:00:00 bash\n</pre>\n\nOn Red Hat Enterprise Linux, SELinux is\
    \ enabled by default and in enforcing mode.  You can confirm this by inspecting\
    \ the output of `sestatus` \non the system.\n\n`sestatus`{{execute T1}}\n\n<pre\
    \ class=\"file\">\nSELinux status:                 enabled\nSELinuxfs mount: \
    \               /sys/fs/selinux\nSELinux root directory:         /etc/selinux\n\
    Loaded policy name:             targeted\nCurrent mode:                   enforcing\n\
    << OUTPUT ABRIDGED >>\n</pre>\n"
  difficulty: basic
  notes:
  - contents: "After completing this scenario, you will be able to run container images\
      \ and generate SELinux profiles customized \nfor your container usecases using\
      \ Udica\n\n# Concepts included in this scenario:\n* Query the allow rules in\
      \ the SELinux policy for the running container\n* Use Udica to generate SELinux\
      \ security profiles for the container \n* Apply policy modules to the container\
      \ based on the Common Intermediate Language (CIL) file generated by Udica\n\
      * Re-query the allow rules in the SELinux policy for the running container to\
      \ ensure that actions are allowed\n\n# Example Usecase:\nThe default container\
      \ type (container_t) is too restricted for certain usecases. For example, if\
      \ Apache wants to read the home  \ndirectory, it is restricted by default. Similarly,\
      \ container_t is too loose for other cases. For example, the Apache running\
      \ in\nthe container can bind to any network port. Using udica can help you write\
      \ a new SELinux security profiles that are customized for \nyour container usecase,\
      \ and does not require deep SELinux expertise to craft.\n"
    type: text
  slug: step1
  tabs:
  - hostname: rhel
    title: Terminal
    type: terminal
  - hostname: rhel
    path: /
    port: 9090
    title: RHEL Web Console
    type: service
  timelimit: 120
  title: Step 1
  type: challenge
- assignment: "# Inspecting container access and SELinux policies\n\nIn 'Terminal\
    \ 2' tab of the lab interface, use a `podman exec` command to create an interactive\
    \ shell inside the running container.\n\n`podman exec -t -i $CONTAINER /bin/bash`{{execute\
    \ T2}}\n\nCheck the container's access to the */home* directory\n\n`cd /home;\
    \ ls`{{execute T2}}\n\n<pre class=\"file\">\nls: cannot open directory '.': Permission\
    \ denied\n</pre>\n\nIn 'Terminal' tab of the lab interface, query the SELinux\
    \ policy to search for allow enforcement rules applied to access */home* directory\n\
    \n`sesearch -A -s container_t -t home_root_t -c dir -p read`{{execute T1}}\n\n\
    The search returns NO results. Since, there is no allow rule for container_t type\
    \ to get read access to the */home* directory, access \nis blocked by SELinux.\n\
    \nIn 'Terminal 2' tab of the lab interface, check the container's access to the\
    \ */var/spool/* directory\n\n`cd /var/spool/; ls`{{execute T2}}\n\n<pre class=\"\
    file\">\nls: cannot open directory '.': Permission denied\n</pre>\n\nSELinux is\
    \ restricting access to the */var/spool* directory.\n\nIn 'Terminal 2' tab of\
    \ the lab interface, check the container's write access to the */var/spool/* directory\n\
    \n`touch test`{{execute T2}}\n\n<pre class=\"file\">\ntouch: cannot touch 'test':\
    \ Permission denied\n</pre>\n\nIn 'Terminal' tab of the lab interface, query the\
    \ SELinux policy to search for allow enforcement rules applied to access */var/spool*\
    \ directory\n\n`sesearch -A -s container_t -t var_spool_t -c dir -p read`{{execute\
    \ T1}}\n\nThe search returns NO results. Since, there is no allow rule for container_t\
    \ type to get read access to the */var/spool/* directory, access \nis blocked\
    \ by SELinux.\n\nQuery the SELinux policy for network access for container_t types\n\
    \n`sesearch -A -s container_t -t port_type -c tcp_socket`{{execute T1}}\n\n<pre\
    \ class=\"file\">\nallow container_net_domain port_type:tcp_socket { name_bind\
    \ name_connect recv_msg send_msg };\nallow corenet_unconfined_type port_type:tcp_socket\
    \ { name_bind name_connect recv_msg send_msg };\nallow sandbox_net_domain port_type:tcp_socket\
    \ { name_bind name_connect recv_msg send_msg };\n</pre>\n\nSandbox is the default\
    \ process type (domain) in SELinux, and container is the domain used in the context\
    \ of containers. The corenet type\nis typically used in the context of the Linux\
    \ kernel. The output means that for each of these domains, binding, connecting,\
    \ sending and receiving \nmessages are allowed without TCP port restrictions.\n"
  difficulty: basic
  slug: step2
  tabs:
  - hostname: rhel
    title: Terminal
    type: terminal
  - hostname: rhel
    path: /
    port: 9090
    title: RHEL Web Console
    type: service
  timelimit: 120
  title: Step 2
  type: challenge
- assignment: '# Generating SELinux container policies with Udica


    To create the custom SELinux security policy, Udica scans the container JSON

    file to discover which Linux capabilities are required by the container. The

    network ports are a similar situation where Udica uses the SELinux userspace

    libraries to get the correct SELinux label of a port that is used by the

    inspected container.


    In the _Terminal_ tab of the lab interface, inspect the running container using

    podman to generate a container inspection file in JSON format


    `podman inspect $CONTAINERID > container.json`{{execute T1}}


    Tell Udica to generate the custom SELinux security policy by using the container

    JSON file. In this case the name of the custom SELinux security policy is called

    ''my_container''


    `udica -j container.json my_container`{{execute T1}}


    <pre class="file">


    Policy my_container created!


    Please load these modules using:

    \# semodule -i my_container.cil /usr/share/udica/templates/{base_container.cil,net_container.cil,home_container.cil}


    Restart the container with: "--security-opt label=type:my_container.process" parameter

    </pre>


    You just created a custom SELinux security policy for the container. Now you can

    load this policy into the kernel and make it active.


    `semodule -i my_container.cil /usr/share/udica/templates/{base_container.cil,net_container.cil,home_container.cil}`{{execute
    T1}}


    For the policies to take effect, stop and re-launch the container


    `podman stop $CONTAINERID`{{execute T1}}


    In ''Terminal 2'' tab of the lab interface, create a new container runtime from

    the image which uses the new, custom container policy


    `CONTAINER=$(podman run --security-opt label=type:my_container.process -v /home:/home:ro
    -v/var/spool:/var/spool:rw -d -p 80:80 -it registry.access.redhat.com/ubi8/ubi)`{{execute
    T2}}

    '
  difficulty: basic
  slug: step3
  tabs:
  - hostname: rhel
    title: Terminal
    type: terminal
  - hostname: rhel
    path: /
    port: 9090
    title: RHEL Web Console
    type: service
  timelimit: 120
  title: Step 3
  type: challenge
- assignment: "# Verifying the SELinux container policies with Udica\n\nYou can verify\
    \ the policies generated using Udica for the container and enforced by SELinux.\
    \ \n\nQuery the SELinux policy on the container host to search for allow enforcement\
    \ rules applied to access */home* directory\n\n`sesearch -A -s my_container.process\
    \ -t home_root_t -c dir -p read`{{execute T1}}\n\n<pre class=\"file\">\nallow\
    \ my_container.process home_root_t:dir { getattr ioctl lock open read search };\n\
    </pre>\n\nThere is an allow rule in place that allows read access to the */home*\
    \ directory.\n\nQuery the SELinux policy on the container host to search for allow\
    \ enforcement rules applied to access */var/spool/* directory.\n\n`sesearch -A\
    \ -s my_container.process -t var_spool_t -c dir -p read`{{execute T1}}\n\n<pre\
    \ class=\"file\">\nallow my_container.process var_spool_t:dir { add_name getattr\
    \ ioctl lock open read remove_name searchwrite };\n</pre>\n\nThere is an allow\
    \ rule in place that allows read access to the *var/spool* directory.\n\nQuery\
    \ the SELinux policy on the container host to check network access \n\n`sesearch\
    \ -A -s my_container.process -t port_type -c tcp_socket`{{execute T1}}\n\n<pre\
    \ class=\"file\">\nallow my_container.process http_port_t:tcp_socket { name_bind\
    \ name_connect recv_msg send_msg };\n</pre>\n\nRetrieve the SELinux type associated\
    \ with TCP port 80. TCP port 80 is the port that Apache will bind on.\n\n`semanage\
    \ port -l | grep -w \"80\"`{{execute T1}}\n"
  difficulty: basic
  slug: step4
  tabs:
  - hostname: rhel
    title: Terminal
    type: terminal
  - hostname: rhel
    path: /
    port: 9090
    title: RHEL Web Console
    type: service
  timelimit: 120
  title: Step 4
  type: challenge
- assignment: "# Re-inspect the running container\n\nIn *Terminal 2* of the lab interface,\
    \ exec into the running container and start a bash shell \n\n`podman exec -t -i\
    \ $CONTAINER /bin/bash`{{execute T2}}\n\nCheck whether container has access to\
    \ the */home* directory\n\n`cd /home/; ls`{{execute T2}}\n\n<pre class=\"file\"\
    >\npacker  rhel\n</pre>\n\nThis is now successful since there is an allow rule\
    \ in place that tells SELinux to allow this action.\n\nCheck whether container\
    \ has read access to the */var/spool/* directory\n\n`cd /var/spool/; ls`{{execute\
    \ T2}}\n\n<pre class=\"file\">\nanacron  cron  lpd  mail  plymouth  rhsm\n</pre>\n\
    \nSimilarly, this is also successful because there is an allow rule in place that\
    \ tells SELinux to allow this action.\n\nCheck whether container has write access\
    \ to the /var/spool/ directory\n\n`touch test; ls`{{execute T2}}\n\n<pre class=\"\
    file\">\nanacron  cron  lpd  mail  plymouth  rhsm  test\n</pre>\n \nInstall the\
    \ netcat (nc) package inside the container to test for port bindings\n\n`yum install\
    \ -y nc`{{execute T2}}\n\nTell nc to listen on port 80 inside the container, and\
    \ timeout after 5 seconds.\n\n`timeout 5s nc -lvvp 80`{{execute T2}}\n\n<pre class=\"\
    file\">\nNcat: Version 7.70 ( https://nmap.org/ncat )\nNcat: Listening on :::80\n\
    Ncat: Listening on 0.0.0.0:80\n</pre>\n\nYou can see from the above output that\
    \ netcat was able to connect and listen on port 80. This is successful \nbecause\
    \ there is a allow rule in place that tells SELinux to allow this network action\
    \ on port 80.\n\nTell nc to listen on port 8080 inside the container, and timeout\
    \ after 5 seconds.\n\n`timeout 5s nc -lvvp 8080`{{execute T2}}\n\n<pre class=\"\
    file\">\nNcat: Version 7.70 ( https://nmap.org/ncat )\nNcat: bind to :::8080:\
    \ Permission denied. QUITTING.\n</pre>\n\nYou can see from the above output that\
    \ netcat was NOT able to connect and listen on port 8080. There is no allow \n\
    rule in place that tells SELinux to allow this operation, and hence it was blocked\
    \ by SELinux.\n"
  difficulty: basic
  slug: step5
  tabs:
  - hostname: rhel
    title: Terminal
    type: terminal
  - hostname: rhel
    path: /
    port: 9090
    title: RHEL Web Console
    type: service
  timelimit: 120
  title: Step 5
  type: challenge
description: "After completing this scenario, you will be able to run container images\
  \ and generate SELinux profiles customized \nfor your container usecases using Udica\n\
  \n# Concepts included in this scenario:\n* Query the allow rules in the SELinux\
  \ policy for the running container\n* Use Udica to generate SELinux security profiles\
  \ for the container \n* Apply policy modules to the container based on the Common\
  \ Intermediate Language (CIL) file generated by Udica\n* Re-query the allow rules\
  \ in the SELinux policy for the running container to ensure that actions are allowed\n\
  \n# Example Usecase:\nThe default container type (container_t) is too restricted\
  \ for certain usecases. For example, if Apache wants to read the home  \ndirectory,\
  \ it is restricted by default. Similarly, container_t is too loose for other cases.\
  \ For example, the Apache running in\nthe container can bind to any network port.\
  \ Using udica can help you write a new SELinux security profiles that are customized\
  \ for \nyour container usecase, and does not require deep SELinux expertise to craft.\n"
developers:
- dopinto@redhat.com
icon: https://logodix.com/logo/1910931.png
level: beginner
owner: rhel
private: false
published: true
skipping_enabled: false
slug: selinux-containers
tags:
- rhel
title: Securing containers with SELinux [Udica]
type: track
